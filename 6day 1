#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#define tm_year tm_year+1900
#define tm_mon tm_mon+1
#define jumpsuper fseek(fs,sizeof(boot_block)+sizeof(super_block),SEEK_SET);
#define jumpinode fseek(fs,(sizeof(boot_block)+sizeof(super_block)+sizeof(inode_block)*512),SEEK_SET);
typedef struct{
	int boot[2];
}boot_block;

typedef struct{
	unsigned long inode_check[8];
	unsigned long data_check[16];
}super_block;

typedef struct inode_block{
	_Bool file_type; // 0:file , 1:directory
	int file_size;
	struct tm* modified_time;
	short db_n[3]; // 0:direct 1:single 2:double
}inode_block;

typedef struct data_block{
	char data[128];
}data_block;

typedef struct data_list{
	char data[128];
	struct data_list *next;
}data_list;

boot_block bb; 

super_block sb;
inode_block ib;
data_block db;
char location[5];
FILE *fs;
data_list pwd;

int check_inode();
int check_data();
int input_prompt();

void mymkfs(){
	bb.boot[0]=0;
	bb.boot[1]=0;
	fs=fopen("myfs","wb+");
	fwrite(&bb,sizeof(boot_block),1,fs);
	fwrite(&ib,sizeof(inode_block),512,fs);
	fwrite(&db,sizeof(data_block),1024,fs);
	rewind(fs);
}

void mymkdir(char tmp[]){

	char dir_name[4]={0};
	char i;
	unsigned short n,bit;
	n=check_data();
	for(i=0;i<4;i++)
		db.data[i]=tmp[i];
	n=check_inode();
	bit=0x3fc&n;
	bit>>=2;
	printf("%d ",strlen(db.data));
	db.data[strlen(db.data)]=bit;
	db.data[strlen(db.data)+1]=0x3&n;
	db.data[strlen(db.data)+2]='\0';
	printf("%d ",strlen(db.data));
	unsigned short result=0;
	result+=db.data[(3)];
	result<<=2;
	result+=db.data[(4)];
	printf("%u",result);





}


int main(){
	FILE *rfs;
	char tmp[10];
	time_t ltime;
	time(&ltime);

	sb.inode_check[0]=1;
	sb.inode_check[0]<<=63;

	sb.data_check[0]=1;
	sb.data_check[0]<<=63;

	input_prompt();
	return 0;

}
int input_prompt(void )
{
	char tmp[40];
	char order[13];
	char prompt[40];
	int i,j;
	fflush(stdin);
	while(1)
	{
		while(1){
			if((fs=fopen("myfs","rb+"))==NULL)
				printf("error : can not find \"myfs\".\n");
			else break;
			scanf("%s",tmp);
			if(0==strcmp("mymkfs",tmp)){ 
				mymkfs();
				getchar();
				break;
			}
		}
		printf("[/%s ]$ ",location);
		scanf("%[^\n]",prompt);
		getchar();


		for(i=0;i<40;i++)
		{  
			if(prompt[i]==' ') break;
			order[i]=prompt[i];
		}
		i++;
		for(j=0;i<40;j++,i++)
			tmp[j]=prompt[i];


		if(0==strcmp("byebye",order)) exit(1);
		/*		else if(0==strcmp("mycat",order)) mycat(tmp);

				else if(0==strcmp("myshowfile",order)) myshowfile(tmp);

				else if(0==strcmp("mypwd",order)) mypwd(tmp);

				else if(0==strcmp("mycd",order)) mycd(tmp);

				else if(0==strcmp("mycp",order)) mycp(tmp);

				else if(0==strcmp("mycpto",order)) mycpto(tmp);

				else if(0==strcmp("mycpfrom",order)) mycpfrom(tmp);

				else if(0==strcmp("myrmdir",order)) myrmdir(tmp);

				else if(0==strcmp("myrm",order)) myrm(tmp);

				else if(0==strcmp("mytouch",order)) mytouch(tmp);

				else if(0==strcmp("myshowinode",order)) myshowinode(tmp);

				else if(0==strcmp("myshowblock",order)) myshowblock(tmp);

				else if(0==strcmp("mystate",order)) mystate(tmp);

				else if(0==strcmp("mytree",order)) mytree(tmp);

		 */
		else if(0==strcmp("mymkdir",order)) mymkdir(tmp);

		else system(prompt);

	}
}
int check_inode(){
	time_t ltime;
	ltime=time(NULL);
	time(&ltime);

	int i,j,count=0;
	unsigned long bit;
	for(i=0;i<8;i++){
		bit=0x1;
		bit<<=63;
		if(sb.inode_check[i]==-1){
			count+=64;
		}
		else if(bit & sb.inode_check[i]){
			for(j=0;j<64;j++){
				if(bit & sb.inode_check[i]){
					count++;
					bit>>=1;
				}
				else{
					sb.inode_check[count/64]|=bit;
					break;
				}
			}
		}
		else{
			sb.inode_check[count/64]|=bit;
			break;
		}
	}

	return count;
}
int check_data(){
	int i,j,count=0;
	unsigned long bit;
	for(i=0;i<16;i++){
		bit=0x1;
		bit<<=63;
		if(sb.data_check[i]==-1){
			count+=64;
		}
		else if(bit & sb.data_check[i]){
			for(j=0;j<64;j++){
				if(bit & sb.data_check[i]){
					count++;
					bit>>=1;
				}
				else{
					sb.data_check[count/64]|=bit;
					break;
				}
			}
		}
		else{
			sb.data_check[count/64]|=bit;
			break;
		}
	}
	return count;
}
